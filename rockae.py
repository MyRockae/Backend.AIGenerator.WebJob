# -*- coding: utf-8 -*-
"""Rockae.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nSMI0rVzSuht_gXGlwfTEDcpVBM5xQsl
"""

pip install google-generativeai tenacity

import google.generativeai as gemini
import json
from typing import Dict, List
import logging
from functools import lru_cache
from tenacity import retry, stop_after_attempt, wait_exponential
import asyncio

class QuizGenerationError(Exception):
    """Custom exception for quiz generation failures"""
    pass

class QuizConfig:
    """Configuration class for quiz generation parameters"""
    def __init__(self):
        self.model_name = "gemini-pro"
        self.temperature = 0.7
        self.max_output_tokens = 2000
        self.valid_difficulties = ["easy", "medium", "hard"]

    def update(self, **kwargs):
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)

class QuizGenerator:
    def __init__(self, api_key: str, config: QuizConfig = None):
        """
        Initialize the QuizGenerator with Gemini API

        Args:
            api_key (str): Gemini API key
            config (QuizConfig, optional): Configuration object
        """
        self.config = config if config else QuizConfig()
        try:
            gemini.configure(api_key=api_key)
            self.model = gemini.GenerativeModel(self.config.model_name)
            self.logger = logging.getLogger(__name__)
        except Exception as e:
            raise QuizGenerationError(f"Failed to initialize Gemini API: {str(e)}")

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
    def _call_api(self, prompt: str) -> dict:
        """Internal method for API call with retry logic"""
        response = self.model.generate_content(
            prompt,
            generation_config={
                "temperature": self.config.temperature,
                "max_output_tokens": self.config.max_output_tokens
            }
        )
        return json.loads(response.text)

    @lru_cache(maxsize=100)
    def generate_quiz(self, difficulty: str, num_questions: int, notes: str, question_type: str = "multiple_choice") -> Dict:
        """
        Generate quiz questions based on provided parameters

        Args:
            difficulty (str): Difficulty level ('easy', 'medium', 'hard')
            num_questions (int): Number of questions to generate
            notes (str): Text content to base questions on
            question_type (str): Type of questions ('multiple_choice', 'true_false')

        Returns:
            dict: JSON-compatible dictionary with quiz questions

        Raises:
            QuizGenerationError: If quiz generation fails
        """
        # Validate inputs
        if not all([difficulty, num_questions, notes]):
            raise QuizGenerationError("All parameters must be provided")

        if difficulty not in self.config.valid_difficulties:
            raise QuizGenerationError(f"Difficulty must be one of {self.config.valid_difficulties}")

        if not isinstance(num_questions, int) or num_questions <= 0:
            raise QuizGenerationError("Number of questions must be a positive integer")

        if question_type not in ["multiple_choice", "true_false"]:
            raise QuizGenerationError("Question type must be 'multiple_choice' or 'true_false'")

        # Construct the prompt
        if question_type == "multiple_choice":
            format_spec = '"options": ["option1", "option2", "option3", "option4"], "correct_answer": "correct option"'
            requirements = "- Each question must have exactly one correct answer and four options"
        else:  # true_false
            format_spec = '"answer": "true" or "false"'
            requirements = "- Each question must be a statement with a true/false answer"

        prompt = f"""
        Generate exactly {num_questions} {question_type} quiz questions based on the following notes.
        Difficulty level: {difficulty}
        Requirements:
        {requirements}
        - Questions must be based solely on the provided notes
        - Make questions appropriate for the specified difficulty level

        Notes: {notes}

        Return the response in this exact JSON format:
        {{
          "quiz": [
            {{
              "type": "{question_type}",
              "question": "question text",
              {format_spec}
            }}
          ]
        }}
        """

        try:
            quiz_data = self._call_api(prompt)
            if not self._validate_response(quiz_data, num_questions, question_type):
                raise QuizGenerationError("Invalid quiz format returned from API")
            return quiz_data

        except json.JSONDecodeError:
            raise QuizGenerationError("Failed to parse API response as JSON")
        except Exception as e:
            self.logger.error(f"API call failed: {str(e)}")
            raise QuizGenerationError(f"Failed to generate quiz: {str(e)}")

    async def generate_quiz_async(self, difficulty: str, num_questions: int, notes: str, question_type: str = "multiple_choice") -> Dict:
        """Async version of generate_quiz (assuming API supports async)"""
        # Same validation as generate_quiz
        if not all([difficulty, num_questions, notes]):
            raise QuizGenerationError("All parameters must be provided")

        if difficulty not in self.config.valid_difficulties:
            raise QuizGenerationError(f"Difficulty must be one of {self.config.valid_difficulties}")

        if not isinstance(num_questions, int) or num_questions <= 0:
            raise QuizGenerationError("Number of questions must be a positive integer")

        if question_type not in ["multiple_choice", "true_false"]:
            raise QuizGenerationError("Question type must be 'multiple_choice' or 'true_false'")

        # Construct prompt (same as synchronous version)
        if question_type == "multiple_choice":
            format_spec = '"options": ["option1", "option2", "option3", "option4"], "correct_answer": "correct option"'
            requirements = "- Each question must have exactly one correct answer and four options"
        else:
            format_spec = '"answer": "true" or "false"'
            requirements = "- Each question must be a statement with a true/false answer"

        prompt = f"""
        Generate exactly {num_questions} {question_type} quiz questions based on the following notes.
        Difficulty level: {difficulty}
        Requirements:
        {requirements}
        - Questions must be based solely on the provided notes
        - Make questions appropriate for the specified difficulty level

        Notes: {notes}

        Return the response in this exact JSON format:
        {{
          "quiz": [
            {{
              "type": "{question_type}",
              "question": "question text",
              {format_spec}
            }}
          ]
        }}
        """

        try:
            # Hypothetical async API call (adjust based on actual Gemini SDK)
            response = await self.model.generate_content_async(
                prompt,
                generation_config={
                    "temperature": self.config.temperature,
                    "max_output_tokens": self.config.max_output_tokens
                }
            )
            quiz_data = json.loads(response.text)
            if not self._validate_response(quiz_data, num_questions, question_type):
                raise QuizGenerationError("Invalid quiz format returned from API")
            return quiz_data
        except json.JSONDecodeError:
            raise QuizGenerationError("Failed to parse API response as JSON")
        except Exception as e:
            self.logger.error(f"API call failed: {str(e)}")
            raise QuizGenerationError(f"Failed to generate quiz: {str(e)}")

    def _validate_response(self, quiz_data: Dict, expected_questions: int, question_type: str) -> bool:
        """
        Validate the structure and quality of the API response

        Args:
            quiz_data (dict): Parsed JSON response
            expected_questions (int): Expected number of questions
            question_type (str): Type of questions expected

        Returns:
            bool: True if valid, False otherwise
        """
        if not isinstance(quiz_data, dict) or "quiz" not in quiz_data:
            return False

        quiz = quiz_data["quiz"]
        if not isinstance(quiz, list) or len(quiz) != expected_questions:
            return False

        questions_seen = set()
        for question in quiz:
            if not all(key in question for key in ["type", "question"]) or question["type"] != question_type:
                return False

            if question_type == "multiple_choice":
                if not all(key in question for key in ["options", "correct_answer"]):
                    return False
                if not isinstance(question["options"], list) or len(question["options"]) != 4:
                    return False
                if question["correct_answer"] not in question["options"]:
                    return False
                if len(set(question["options"])) != 4:  # Ensure distinct options
                    return False
            else:  # true_false
                if "answer" not in question or question["answer"] not in ["true", "false"]:
                    return False

            if question["question"] in questions_seen:
                return False  # No duplicate questions
            questions_seen.add(question["question"])

        return True

# Example usage
def main():
    try:
        # Replace with your actual API key
        api_key = "your-gemini-api-key-here"
        config = QuizConfig()
        config.update(temperature=0.5, max_output_tokens=1500)
        generator = QuizGenerator(api_key, config)

        # Sample parameters
        difficulty = "medium"
        num_questions = 2
        notes = """A dog is a domesticated mammal from the species *Canis lupus familiaris*,
        known for its loyalty, intelligence, and companionship with humans. Descended
        from wolves, dogs have been bred for various roles, including hunting, herding,
        guarding, and assisting people."""

        # Generate quiz (synchronous)
        quiz = generator.generate_quiz(difficulty, num_questions, notes, question_type="multiple_choice")
        print("Synchronous Quiz:")
        print(json.dumps(quiz, indent=2))

    except QuizGenerationError as e:
        print(f"Error: {str(e)}")
    except Exception as e:
        print(f"Unexpected error: {str(e)}")

async def main_async():
    try:
        api_key = "your-gemini-api-key-here"
        generator = QuizGenerator(api_key)

        difficulty = "medium"
        num_questions = 2
        notes = """A dog is a domesticated mammal from the species *Canis lupus familiaris*,
        known for its loyalty, intelligence, and companionship with humans."""

        # Generate quiz (asynchronous)
        quiz = await generator.generate_quiz_async(difficulty, num_questions, notes, question_type="true_false")
        print("Asynchronous Quiz:")
        print(json.dumps(quiz, indent=2))

    except QuizGenerationError as e:
        print(f"Error: {str(e)}")
    except Exception as e:
        print(f"Unexpected error: {str(e)}")

if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)

    # Run synchronous example
    main()

    # Run asynchronous example
    asyncio.run(main_async())